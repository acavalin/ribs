#!/usr/bin/env ruby

require 'optparse'
require 'fileutils'
require 'shellwords'
require 'zlib'
require 'yaml'

$VERBOSE = nil
STDOUT.sync = true

TAR_OPTS  = '--numeric-owner -p'
TAR_COMPR = { 'txz' => '-J', 'tgz' => '-z' } # tar compression switches

# file types skipped/ignored
SKIPPED_FTYPES = %w{ socket unknown characterSpecial blockSpecial } # file directory link fifo
SKIPPED_FOLDERS = %w{ . .. }

def die(msg, exit_code = 0); puts msg; exit exit_code; end

die "you are not root!" if Process.uid != 0

# --- setup options ------------------------------------------------------------
# default options
options = {
  src_dir:  nil,
  dst_dir:  nil,
  one_fs:   true,
  one_fs_skipped: [],
  exclude: %w{
    /var/tmp/*
    /var/log/*.?.gz
    /var/backups/*.?.gz
  },
  perms:    true,
  zip_zip:  :xz,
  zip_ext:  :txz,
}

# imposta opzioni da riga di comando
optparser = OptionParser.new do |op|
  op.banner = "USAGE: #{File.basename $0} [switches] <repository-folder> <target-folder>"
  op.on('-b', '--backup'              , "update the incremental backup repo"   ){ options.merge! action: :backup }
  op.on('-r', '--restore'             , "restores the last backup version"     ){ options.merge! action: :restore, target: :last }
  op.on('-R', '--restore-ts TIMESTAMP', "restores the specified backup version"){|ts| options.merge! action: :restore, target: ts }
  op.on('-l', '--list-ts'             , "show available restorable versions"   ){ options.merge! action: :list_ts }
  op.on('-g', '--gzip'                , "use gzip instead of xz"               ){ options.merge! zip_zip: :gzip, zip_ext: :tgz }
  op.on('-G', '--pigz'                , "use parallel gzip instead of xz"      ){ options.merge! zip_zip: :pigz, zip_ext: :tgz }
  op.on('-x', '--[no-]one-file-system', "don't cross filesystem boundaries        Def. #{options[:one_fs]}"){|v| options.merge! one_fs: v }
  op.on('-p', '--[no-]permissions'    , "store files permissions (gid/uid/modes)  Def. #{options[:perms] }"){|v| options.merge! perms:  v }
  op.on('-h', '--help'                , 'display this help'                    ){
    puts "#{op}\n"
    puts <<~END
      Some files are automatically excluded, you can insert any additional GLOBs patterns
      by wrinting them in repo_dir/exclude.yml. This is the default list:
      #{options[:exclude].map{|i| "  - #{i}\n"}.join }
    END
    exit 1
  }
end

begin
  optparser.parse! ARGV
rescue OptionParser::ParseError
  die $!, 1
rescue SystemExit
  exit 1
end

options[:dst_dir], options[:src_dir] = ARGV

die("invalid repository", 1) unless options[:dst_dir] && File.exist?(options[:dst_dir])
die("invalid target"    , 1) unless options[:src_dir] && File.exist?(options[:src_dir])
die("no b/r/l switch fround", 1) unless options[:action]

options[:src_dir] = File.expand_path options[:src_dir]
options[:dst_dir] = File.expand_path options[:dst_dir]

options[:src_dev] = File.lstat(options[:src_dir]).dev

# number of chars to trim from beginnin of file names to store them on the DB
options[:src_size]  = options[:src_dir].size
options[:src_size] += 1 if options[:src_dir] != '/'

# --- listing available versions -----------------------------------------------
if options[:action] == :list_ts
  puts Dir.chdir(options[:dst_dir]){ Dir['????-??-??_??-??-??'].sort{|a,b| b<=>a } }
end

# --- performing backup --------------------------------------------------------
if options[:action] == :backup
  # recursively scan folder, build DB, and write log file
  def stat_folder(folder, db, log, options)
    print "#{db.size} files found\r"
    
    Dir.entries(folder).each do |f|
      next if SKIPPED_FOLDERS.include?(f)
  
      fp = File.join  folder, f
      s  = File.lstat fp
  
      next if SKIPPED_FTYPES.include?(s.ftype)
  
      fkey = fp[options[:src_size] .. -1] # trim base path
      
      if options[:one_fs] && s.directory? && options[:src_dev] != s.dev
        STDERR.puts "SKIPPED #{fp.ljust(40)}"
        options[:one_fs_skipped] << fkey
        next
      end

      if options[:exclude].any?{|pattern| File.fnmatch pattern, "/#{fkey}", File::FNM_DOTMATCH | File::FNM_EXTGLOB }
        STDERR.puts "EXCLUDE #{fp.ljust(40)}"
        next
      end

      db[fkey]  = options[:perms] ?
        [s.gid, s.uid, s.mode, s.ftype[0], s.size, s.mtime.to_i].join('|') :
        [nil, nil, nil, s.ftype[0], s.size, s.mtime.to_i].join('|')
      db[fkey] += "|#{File.readlink(fp)}" if s.symlink?
  
      log.puts "#{db[fkey]}\t#{fkey}"
  
      stat_folder(fp, db, log, options) if s.directory? && options[:src_dev] == s.dev
    end
  end # stat_folder

  # read exclude pattern list
  fname = File.join options[:dst_dir], 'exclude.yml'
  options[:exclude] += YAML.load_file(fname) if File.exist?(fname)

  # create base folder in the repository
  cur_ts = File.join options[:dst_dir], Time.now.strftime('%F_%H-%M-%S')
  FileUtils.mkdir_p cur_ts
  
  # populate current data
  cur_db = {} # file_path => stat data
  Zlib::GzipWriter.open(File.join cur_ts, 'stats.dat') do |gz|
    gz.mtime, gz.orig_name = Time.now, 'stats.dat'
    stat_folder options[:src_dir], cur_db, gz, options
    puts "#{cur_db.size} files found"
  end

  # load previous data from disk
  old_ts = Dir[File.join options[:dst_dir], '????-??-??_??-??-??'].sort[-2..-2]
  old_ts = old_ts.first if old_ts.is_a?(Array)
  old_db = {} # file_path => stat data
  Zlib::GzipReader.open(File.join old_ts, 'stats.dat') do |gz|
    gz.each_line do |line|
      props, name = line.strip.split "\t"
      old_db[name] = props
    end
  end if old_ts
  
  # it's the first backup, do it and exit
  unless old_ts
    Dir.chdir options[:src_dir]
    fdest = File.join(cur_ts, "files.#{options[:zip_ext]}").shellescape
    system "tar #{TAR_OPTS} -cf - . | pv -N archiving -w 40 | #{options[:zip_zip]} -c > #{fdest}"
    exit
  end

  # compare the last two DBs
  to_arc = [] # files to archive (different type/size/mtime)
  diffs  = {} # files with different GID/UID/Mode
  skip_dir = nil # skip entries in this folder
  old_db.each do |name, o_props|
    if options[:one_fs_skipped].include?(name)
      options[:one_fs_skipped].delete name
      skip_dir = name
      next
    end
 
    next if options[:exclude].any?{|pattern| File.fnmatch pattern, "/#{name}", File::FNM_DOTMATCH | File::FNM_EXTGLOB }
    
    next if skip_dir && name.start_with?("#{skip_dir}/")
    skip_dir = nil
    
    if c_props = cur_db[name]
      o_gid, o_uid, o_mode, o_type, o_size, o_mtime, o_link = o_props.split("|")
      c_gid, c_uid, c_mode, c_type, c_size, c_mtime, c_link = c_props.split("|")

      to_arc << name if "#{o_type}#{c_type}" != 'dd' && "#{o_size}|#{o_mtime}" != "#{c_size}|#{c_mtime}"

      if o_type == c_type
        link_changed = o_link != c_link
        diffs[name] = {}
        if options[:perms]
          diffs[name][:gid ] = c_gid .to_i if o_gid != c_gid || link_changed
          diffs[name][:uid ] = c_uid .to_i if o_uid != c_uid || link_changed
          diffs[name][:mode] = c_mode.to_i if c_type != 'l' && o_mode != c_mode # a link has always 777
        end
        diffs[name][:link] = c_link if link_changed
        diffs.delete name if diffs[name].empty?
      else
        diffs[name] = :rm
        if c_type == 'd'      # typechange: from * to directory
          # avoid archiving files from an already archived parent folder
          cur_db.keys.each{|k| cur_db.delete k if k.start_with?("#{name}/") }
        elsif o_type == 'd'   # typechange: from directory to *
          # do not delete files from an already deleted parent folder
          skip_dir = name
        end
      end
      
      cur_db.delete name
    else
      diffs[name] = :rm
      # do not delete files from an already deleted parent folder
      skip_dir = name
    end
  end
  to_arc += cur_db.keys # add new files
  
  # archive changed/new files
  if to_arc.size > 0
    puts "#{to_arc.size} new/modified files"
    flist = File.join(cur_ts, 'files.list')
    fdest = File.join(cur_ts, "files.#{options[:zip_ext]}")
    File.open(flist, 'w'){|f| f.puts to_arc }
    tar_opts = "-C #{options[:src_dir]} -cf - --verbatim-files-from --files-from #{flist.shellescape}"
    system "tar #{TAR_OPTS} #{tar_opts} | pv -N archiving -w 40 | #{options[:zip_zip]} -c > #{fdest}"
    system "gzip #{flist.shellescape}"
  end
  
  # save differences in UID/GID/Mode
  if diffs.size > 0
    puts "#{diffs.size} files removed/attr.changed"
    Zlib::GzipWriter.open(File.join cur_ts, 'diff.ymz') do |gz|
      gz.mtime, gz.orig_name = Time.now, 'diff.yml'
      gz.puts diffs.to_yaml
    end
  end
  
  # remove folder if nothing has changed
  FileUtils.rm_rf(cur_ts) if (to_arc.size + diffs.size) == 0
end # action :backup

# --- performing restore -------------------------------------------------------
if options[:action] == :restore
  versions = Dir[File.join options[:dst_dir], '????-??-??_??-??-??'].sort
  options[:target] = versions.last if options[:target] == :last
  
  die("non existent version [#{options[:target]}]", 2) unless versions.any?{|v| v.end_with? options[:target] }
  
  versions.each do |ver|
    print "#{File.basename(ver)}: "
    
    if fname = Dir[File.join ver, 'diff.ymz'].first
      changes = Zlib::GzipReader.open(fname){|gz| YAML.load gz }
      die("unsupported format!", 4) unless changes.is_a?(Hash)
      print "diff... "
      changes.each do |fname, chg|
        fname = File.join(options[:src_dir], fname)
        die("file not found [#{fname}]", 5) unless File.exist?(fname)
        
        if chg == :rm
          FileUtils.rm_rf fname
        elsif chg.is_a?(Hash)
          if chg[:link]
            File.unlink fname
            File.symlink chg[:link], fname
          end
          if chg[:gid] || chg[:uid]
            chg[:gid] ||= File.lstat(fname).gid
            chg[:uid] ||= File.lstat(fname).uid
            File.lchown chg[:uid], chg[:gid], fname
          end
          File.chmod(chg[:mode], fname) if chg[:mode]
        else
          die "diff instruction unknown [#{chg.inspect}]", 6
        end
      end
    end
    
    if fname = Dir[File.join ver, 'files.???'].first
      die("unsupported compression!", 3) unless tar_compr = TAR_COMPR[fname.split('.').last]
      print "untar... "
      system "tar #{TAR_OPTS} -C #{options[:src_dir]} #{tar_compr} -xf #{fname.shellescape}"
    end
    
    puts ''
    
    break if ver.end_with? options[:target]
  end
end
